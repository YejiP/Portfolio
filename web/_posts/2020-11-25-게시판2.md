# 게시판2) 회원가입 페이지

```
내용이 많기 때문에 모든 부분을 다 다루기 보다는, 중요한 부분만을 다룰것이다.
```

- jsp와 controller 가 어떻게 정보를 주고 받는지 모르는 사람은 [여기](http://yejip.com/web/2020-11-16-SpringOracle3Cont/)를 먼저 보고 오세요
- index 화면 구상을 아직 하지 않아서 코드로만ㅎㅎ..
- 아래 회원가입을 누르면 join 이라는 요청이 controller로 날아가게 한다. get method로 날아간다. 

# FRONTEND

## **index.jsp**

```jsp
<li><a href = "join">회원가입</a></li>
```

## **controller - @RequestMapping("/join")**

```java
@Controller
public class MemberController {
    @RequestMapping("/join")
    public String join() {
        return "member/joinForm";
    }
```

## member/**joinForm.jsp**

<img width="501" alt="1124sp9" src="https://user-images.githubusercontent.com/37058233/100231369-4411fb00-2f6a-11eb-9a6b-2225edc549aa.PNG">

## **js 파일의 위치**

- member/joinForm.jsp의 header에는 다음과 같은 코드가 있다. 

  ```jsp
  <head>
      <script src="script/validation.js"></script>
  </head>
  ```

- 이 js파일은 엉뚱하게

  <img width="164" alt="1125sp3" src="https://user-images.githubusercontent.com/37058233/100232280-8556da80-2f6b-11eb-87f6-a65082899fa8.PNG"> src/main/webapp/resources/script 아래에 있다. 

  이 경로를 인식시켜주기 위해서 **servlet-context**에 다음과 같은 코드를 넣어준다.

  <img width="829" alt="1125sp2" src="https://user-images.githubusercontent.com/37058233/100232572-de267300-2f6b-11eb-9450-12db7d50b526.PNG">

  ```xml
  <resources mapping="/script/**" location="/resources/script/" />
  ```

## **form의 id와 action**

```jsp
<form id="form" action = "join" method ="POST">
```

**id**는 js에서 validation 을 마친 후 제출할 때 사용되어진다.

```js
var form = document.getElementById("form");
form.submit();
```

**action 과 method**는 Controller의 메쏘드와 mapping 되는 정보를 준다.

아래 함수로 mapping 된다.

```java
@RequestMapping(value = "/join", method = RequestMethod.POST)
public String join(Member member) {
    System.out.println(member);
    return "index";
}
```

## **ID 중복확인**

- 아래와 같이, ID 중복 확인을 누르면 작은 화면이 떠, 그 화면에서 중복확인을 할 수 있게 할 수 있도록 할 것이다. 부모창에서 자식창을 띄우고 그 값을 입력받는 것은 [다음](http://yejip.com/web/2020-11-07-JS_HO5/)에 잘 설명해 놓았다.

<img width="720" alt="1125sp5" src="https://user-images.githubusercontent.com/37058233/100542315-75e9d100-328c-11eb-8c9b-64b68873552f.PNG">

- 여기선 어떻게 DB에서 중복된 데이터를 찾을 수 있는 지를 보도록 할 것이다. ajax를 사용하면 실시간으로 간편하게 이 기능을 구현할 수 있다고 한다. 그것은 나중에 해보도록 하고, 오늘은 좀 복잡한 방법으로 기능을 구현할 것이다.

- 버튼을 누르면 서버에 정보를 보낸다. 아래 코드를 보면, form 의 method를 POST로 정했기 때문에, controller 객체의 **@RequestMapping(value="/idCheck", method= RequestMethod.POST)** 를 찾아간다.

  **idCheck.jsp**

  ```jsp
  <form action="" method="POST" id="form">
      <input type="text"id ="userid"  name = "userid" value = "${userid}" placeholder = "검색할 ID 입력">
      <input type="button" id = "btn_idcheck" value= "검색">
  </form>
  ```

  **idCheck.javascript**

  ```javascript
  var form = document.getElementById("form");
  form.submit();
  ```
- 위와 매핑되는 컨트롤러의 함수이다. 위에서 name:value의 형태로 서버에 정보가 넘어간다. (userid : ${userid}). 이걸 member로 받았다. 근데 아마 **스프링 측에서 userid 에 setter 함수를 불러서 알아서 처리해 줄 것 같다 (확인하기)** 그래서 arg로 들어온 member 인스턴스에는 userid의 정보만 있고 다른 애들은 다 null값을 가진다.

  ```java
  //id 중복확인 처리 요청
  @RequestMapping(value="/idCheck", method= RequestMethod.POST)
  public String idCheck(Member member, Model model){
      //select * from member where userid = #{};
      Member m = repository.selectOne(member);
      model.addAttribute("member",m);
      model.addAttribute("userid",member.getUserid());
      return "member/idCheck";
  }
  ```

  id 정보를 member 에 담아 repository.selectOne() 함수를 사용해 m을 리턴 받는다. 만약 찾았으면 m이 null 이 아니고, 못찾았으면 null 일 것이다. 이 작업이 끝나면 member/idCheck으로 다시 돌아가야기 때문에 리턴을 저렇게 해준다.

- **idCheck.jsp**
- 컨트롤러 함수에서 작업을 처리한 후 돌아왔다. 서버에는 member이라는 이름의 객체가 있다. 만약 null이면 못찾은 것이니까 id 사용가능. 그리고 이 문구는 항상 pageContext.request.method 가 POST 방식일 때에만 보여야한다. 그래서 아래와 같은 조건을 써준다.

```jsp
<c:if test="${pageContext.request.method eq 'POST' and  member.userid eq null}">
    <span>${userid}는 사용가능한 id입니다.</span>
    <input type = "button" id = "userid" value = "ID 사용하기" onclick="idSelect('${userid}')"></c:if>

<c:if test="${ pageContext.request.method eq 'POST' and member.userid ne null}">
    <span>${userid}는 사용할 수 없는 id입니다.</span></c:if>
```

##  **select와 for문**

- 페이지 위에 페이지 jstl을 이용하기 위한 페이지 지시자를 사용해야한다.

```jsp
<%@taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
```

- 아래와 같이 forEach문과 option 을 같이 사용해 쉽게 설렉트 박스를 만들 수 있다.
- begin 과 end로 시작과 끝 값을 줄 수 있다.

```jsp
<th>생년월일</th>
<td><select id ="birthyear"><!-- 1960~2000 -->
    <c:forEach var="year" begin="1960" end="2000" >
        <option>${year}</option>
    </c:forEach>
    </select>년
```

## **hidden으로 서버에 정보 넘기기**

일단 '회원가입' 버튼을 누르면 생년, 월,일의 정보의 유효성을 확인한다. 

```jsp
<input type = "hidden" id= "birth" name="birth">
```

- 만약 정보가 제대로 들어갔다면, js에서 생년월일을 하나의 string 으로 저장해 hidden tag의 value로 꽂아준다. 

**javascript**

```javascript
birth = birthyear.value +'-'+ birthmonth.value + "-" + birthday.value ;
document.getElementById("birth").value = birth;
//위 코드 실행 후 다음과 같이 value가 꽂힌다.
//<input type = "hidden" id= "birth" name="birth" value = 2010-03-21>
```

- 그 후 서버에 정보를 넘길 수 있게 form.submit()을 해준다.

**javascript**

```javascript
var form = document.getElementById("form");
form.submit();
```

form. submit()의 명령을 하면, action = "join", method = "POST"의 정보가 

```jsp
<form id="form" action = "join" method ="POST">
```

**Controller** 의 함수와 매치된다. contoller의 code는

```java
@RequestMapping(value = "/join", method = RequestMethod.POST)
public String join(Member member) {
    //CODE
}
```

# BACKEND

- 매퍼 파일인 **memberMapper.xml** 에 다음과 같은 코드를 삽입해준다.
- 이 전 블로그 포스트 [여기](http://yejip.com/web/2020-11-16-SpringOracle3Cont/)에 나름 친절하게 나와있어서 이 포스트에서는 간단하게 코드와 흐름만 볼 것이다.
- insert id ="join"이고, 이것이 interface의 메소드 명과 매치되고, 그 메소드의 인자 타입을 parameterType 에 적어주면 된다.

```xml
<mapper namespace="sesoc.intern.board.dao.MemberMapper">
    <insert id="join" parameterType="Member">
        INSERT INTO member
        VALUES
        (
        #{userid}
        ,#{userpwd}
        ,#{username}
        ,#{gender}
        ,#{email}
        ,#{phone}
        ,#{hobby}
        ,#{birth}
        ,#{address}	
        )
    </insert>
</mapper>
```

- **interface**

```java
public interface MemberMapper {
    public int join(Member mebmer);
}
```

- **repository**에서 interface를 이용해 member를 join 시키고 그 결과로 int를 받아 return 한다. int가 리턴되는 것은 mapper.xml 에서 코드가 실행된 후 나타난다.

```java
public class MemberRepository {
    @Autowired
    SqlSession session;
    public int join(Member member) {
        MemberMapper  mapper = session.getMapper(MemberMapper.class);
        int result = mapper.join(member);
        return result;
    }
}
```

- **Controller**에서는 Autowired로 repository 객체를 불러서 join 작업을 해준다. 

```java
@Controller
public class MemberController {
    @Autowired
    MemberRepository repository;

    @RequestMapping(value = "/join", method = RequestMethod.POST)
    public String join(Member member) {
        System.out.println(member);
        int result =repository.join(member);
        if(result ==1) {
            System.out.println("회원가입 성공");
        }else {
            System.out.println("회원가입 실패");
        }
        return "index";
    }
}
```

# 끝