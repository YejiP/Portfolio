---
layout: post
title: 합병정렬 알고리즘
description: > 합병정렬을 java와 python으로 구현해보고, 사용할 수 있는 라이브러리를 알아본다
---

# 합병정렬

## **알고리즘 설명**

**IDEA :** 두 개의 정렬된 배열이 주어졌을 때, 정렬된 하나의 배열로 합병. 이걸 divide-and-conquer 방법으로.

1. 배열 원소가 하나가 될 때 까지 배열을 반으로 쪼개고 쪼개고 쪼갠다.
2. 거기서 부터 정렬시작! 
3. 함수(배열, 시작점, 끝점) 로 recursive하게 

## **성능 분석**

**일단 합병정렬 말고,** 정렬된 두개 배열을 합칠 때 성능을 보면 다음과 같다. 

- 주요 함수는 comparison 과 movement
- comparison의 횟수, n1+n2
- comparison 은 n1+n2 보다 작거나 같다.

**합병정렬 성능**

- 재귀트리를 이용해 나타내면 더 이해하기 쉽다.
- Θ(nlogn)

## **JAVA 코드**

- 푸는 방법이 여러개다. 나는 좀 안 깔끔하게 풀긴 했다. 세련된 코드를 외우도록 해보자.

- 일단 이중 for문을 사용했고, 그 for 문을 다 돌면 ary가 정렬이 되는게 아니라서 좀 지저분하게 조건을 추가했다.

  1. 첫번째 배열 : 첫번째 for 문으로 순회 (start 에서 mid)
  2. 두번째 배열 : 두번째 for 문은 (mid에서 end)

  - 여기서 헷갈리지말아야하는게, 첫번째 두번째 배열은 사실 한 배열이고, index로 두개처럼 우리가 임의로 생각하는 것이다.

- 경우의 수는 다음과 같다. 

  1. 첫번째 배열(ary,start,mid)은 새 배열(n_ary)에 정렬이 되었는데, 두번째 배열(ary,mid,end)은 아직 안됨  
     - 이 경우, 이중for문 밖에 나온 상태라다. 이중 for문 안에서 두번째 배열이 어디까지 진행됐는지 알기 위해 check라는 변수를 사용해 확인하고, 또 for문을 돌려 end전까지 **두번째 배열 원소들을 n_ary에 순서대로 차곡차곡** 넣어준다.
  2. 두번째 배열(ary,mid,end)이 새 배열(n_ary) 다 정렬되었는데 , 첫번째 배열(ary,start,mid)은 아직 안됨.
     - 이 경우는 두번째 for문은 다 돈 상태다. 그러므로 첫번째 for문은 끝나지 않았다. ptr이라는 변수로 확인해주고 n_ary가 어디까지 차있는지 확인하고 **첫번째 배열 원소들을 n_ary에 순서대로 차곡차곡** 넣어준다.

```java
static int[] ary = {11,120,89,3,5,2,122,13,22,123,1222};
static int[] n_ary = new int[ary.length];

public static void main(String[] args) {
    merge_sort(ary,0,ary.length);
    System.out.println("결과들 : " +Arrays.toString(n_ary) );
}

public static void merge_sort(int[] ary,int start,int end){
    int mid =(end+start)/2;

    if(start>=end-1){
        return;
    }else{
        merge_sort(ary,start,mid);
        merge_sort(ary,mid,end);
    }

    int ptr=start;
    int check = mid;

    for(int i =start;i<mid;i++) {
        for(int j=check;j<end;j++){
            if(ary[i]>ary[j]){
                n_ary[ptr]=ary[j];
                check = j+1;
            }else{
                n_ary[ptr]=ary[i];
                j=end+1;
            }
            ptr++;
        }
        if(ptr <end) {
            if(check>=end) {
                n_ary[ptr]=ary[i];
                ptr++;}
        }
    }
    for(int j=check;j<end;j++) {
        n_ary[ptr] = ary[j];
        ptr++;
    }

    for(int i =start ; i<end;i++) {
        ary[i] = n_ary[i];
    }	

}
```

## **PYTHON 코드**

- 위에 좀 지저분하게(?) 푼 것 같아서, 이번에는 while문의 세련된 코드를 **가져왔다.** 2017년도 파이썬 수업 들은 거에서 가져옴.. 여기선 두개 함수를 만들어 풀었다.

```python

```

